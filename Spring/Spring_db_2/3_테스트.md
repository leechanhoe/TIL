# 3. 데이터 접근 기술 - 테스트
![](https://velog.velcdn.com/images/dodo4723/post/0f7908ca-17ad-4b55-a243-09ab2b0c57d7/image.png)

[김영한 개발자님의 스프링 DB 2편 강의](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-db-2#reviews)를 수강하고 중요한 내용을 정리했습니다.

<br>

## 3.1. 테스트 - 데이터베이스 분리

실제 데이터베이스를 연동해서 테스트를 하면 데이터베이스에 이미 과거에 서버를 실행하면서 저장했던 데이터가 보관되어 있기 때문에 이 데이터가 현재 테스트에 영향을 준다.

이런 문제를 해결하려면 테스트를 다른 환경과 철저하게 분리해야 한다.

**가장 간단한 방법은 테스트 전용 데이터베이스를 별도로 운영하는 것이다.**

H2 데이터베이스를 용도에 따라 2가지로 구분하면 된다.
- `jdbc:h2:tcp://localhost/~/test` local에서 접근하는 서버 전용 데이터베이스
- `jdbc:h2:tcp://localhost/~/testcase` test 케이스에서 사용하는 전용 데이터베이스

하지만 테스트를 2번 이상 실행하면 이전 테스트에서 저장된 데이터가 계속 남아있을 수 있다. 그러므로 각각의 테스트가 끝날 때 마다 해당 테스트에서 추가한 데이터를 삭제해야 한다. 

#### 테스트에서 매우 중요한 원칙은 다음과 같다.
> 테스트는 다른 테스트와 격리해야 한다.
> 테스트는 반복해서 실행할 수 있어야 한다.

테스트가 끝날 때 마다 추가한 데이터에 DELETE SQL 을 사용할 수도 있지만, 비정상적으로 종료됐을 때 DELETE SQL 을 호출하지 못할 수 도 있다.

<br>

## 3.2. 테스트 - 데이터 롤백

테스트가 끝나고 나서 **트랜잭션을 강제로 롤백**해버리면 데이터가 깔끔하게 제거된다.

테스트를 하면서 데이터를 이미 저장했는데, 중간에 테스트가 실패해서 롤백을 호출하지 못해도 트랜잭션을 커밋하지 않았기 때문에 데이터베이스에 해당 데이터가 반영되지 않는다.

```java
//class ItemRepositoryTest
@Autowired
ItemRepository itemRepository;

 //트랜잭션 관련 코드
@Autowired
PlatformTransactionManager transactionManager;
TransactionStatus status;

@BeforeEach
void beforeEach() {
 	//트랜잭션 시작
 	status = transactionManager.getTransaction(new DefaultTransactionDefinition());
}

@AfterEach
void afterEach() {
	//MemoryItemRepository 의 경우 제한적으로 사용
 	if (itemRepository instanceof MemoryItemRepository) {
 		((MemoryItemRepository) itemRepository).clearStore();
 	}
 	//트랜잭션 롤백
	transactionManager.rollback(status);
}
```

<br>

## 3.3. 테스트 - @Transactional
스프링은 테스트 데이터 초기화를 위해 트랜잭션을 적용하고 롤백하는 방식을 `@Transactional` 애노테이션 하나로 깔끔하게 해결해준다.

위 코드의 클래스에 `@Transactional`을 붙이면 끝난다.
```java
@Transactional
@SpringBootTest
class ItemRepositoryTest {}
```

### @Transactional 원리

![](https://velog.velcdn.com/images/dodo4723/post/d1205cec-04a4-436c-90cf-4fa1c8d42e08/image.png)

### 강제로 커밋하기 - @Commit
정말 가끔은 데이터베이스에 데이터가 잘 보관되었는지 최종 결과를 눈으로 확인하고 싶을 때도 있다.
`@Commit` 이나 `@Rollback(value = false)` 를 붙여주면 된다.

```java
//@Rollback(value = false)
@Commit
@Transactional
@SpringBootTest
class ItemRepositoryTest {}
```

<br>

## 3.4. 테스트 - 임베디드 모드 DB
테스트 케이스를 실행하기 위해서 별도의 데이터베이스를 설치하고, 운영하는 것은 상당히 번잡한 작업이다.

### 임베디드 모드
H2 데이터베이스는 자바로 개발되어 있고, JVM안에서 메모리 모드로 동작하는 특별한 기능을 제공한다. 그래서 애플리케이션을 실행할 때 H2 데이터베이스도 해당 JVM 메모리에 포함해서 함께 실행할 수 있다.

**애플리케이션에서 자바 메모리를 함께 사용하는 라이브러리처럼 동작한다.**

### 임베디드 모드 직접 사용

```java
@Import(JdbcTemplateV3Config.class)
@SpringBootApplication(scanBasePackages = "hello.itemservice.web")
public class ItemServiceApplication {
	public static void main(String[] args) {
		SpringApplication.run(ItemServiceApplication.class, args);
	}

	@Bean
	@Profile("test") // 프로필이 test 인 경우에만 데이터소스를 스프링 빈으로 등록
	public DataSource dataSource() {
		log.info("메모리 데이터베이스 초기화");
		DriverManagerDataSource dataSource = new DriverManagerDataSource();
		dataSource.setDriverClassName("org.h2.Driver");
		dataSource.setUrl("jdbc:h2:mem:db;DB_CLOSE_DELAY=-1");
		dataSource.setUsername("sa");
		dataSource.setPassword("");
		return dataSource;
	}
}
```
`jdbc:h2:mem:db` : 이 부분이 중요하다. 데이터소스를 만들때 이렇게 적으면 임베디드 모드(메모리 모드)로 동작하는 H2 데이터베이스를 사용할 수 있다.

`DB_CLOSE_DELAY=-1` : 임베디드 모드에서는 데이터베이스 커넥션 연결이 모두 끊어지면 데이터베이스도 종료되는데, 그것을 방지하는 설정이다.

그런데 막상 실행해보면 메모리 DB에는 **아직 테이블을 만들지 않아** 오류가 발생한다.

### 스프링 부트 - 기본 SQL 스크립트를 사용해서 데이터베이스를 초기화하는 기능

JDBC나 JdbcTemplate를 직접 사용해서 테이블을 생성하는 DDL을 호출해도 되지만, 너무 불편하다.

스프링 부트는 SQL 스크립트를 실행해서 애플리케이션 로딩 시점에 데이터베이스를 초기화하는 기능을 제공한다.

다음 파일을 `//src/test/resources/schema.sql`에 생성하면 된다. 파일이름과 위치가 맞아야한다.
```sql
drop table if exists item CASCADE;
create table item
(
 	id bigint generated by default as identity,
 	item_name varchar(10),
 	price integer,
 	quantity integer,
 	primary key (id)
);
```

<br>

## 3.5. 테스트 - 스프링 부트와 임베디드 모드

스프링 부트는 데이터베이스에 대한 별다른 설정이 없으면 임베디드 데이터베이스를 사용한다.

[메모리 DB용 데이터소스 설정](#임베디드-모드-직접-사용)과 아래의 `application.properties`의 데이터베이스 설정정보도 지워도 된다.
```
spring.datasource.url=jdbc:h2:tcp://localhost/~/testcase
spring.datasource.username=sa
jdbcTemplate sql log
```

**이렇게 별다른 정보가 없으면 스프링 부트는 임베디드 모드로 접근하는 데이터소스(DataSource)를 만들어서 제공한다.**